"""

프로그래머스 탐욕법_단속카메라 : LEVEL 3

레벨3답게 어려운 문제다. 고민하다가 방법이 생각이 안나서,
인터넷을 참고했더니 이해를 하니깐 엄청 쉬운문제였다.

우선 어떤방법을 사용하든 진출 시점을 기준으로 오름차순 정렬을 한다.
이제 방법은 2가지가 있다.
첫번째는 시간복잡도가 O(n^2)가 되는방법
두번째 방법은 시간복잡도가 O(n*log n)이 되는방법 (둘다 일단 무조건 정렬을 한번해야하기때문에, O(n * log n) 보다 빠르게 될수없긴함)

첫번째 방법은 정렬 후, check = [False] * len(routes) 배열을 만들고,
진출기점을 기준으로 반복문을 돌리는 방법이다. 근데 이중반복문을 써야되는 방법이라 O(n^2)이 나와서 비효율적
물론 이걸로도 문제는 맞출수 있긴하다, 효율성 테스트도 통과할수있고, 근데 아래 기술된 방법이 더 좋아서 아래껄로 복습하자.

두번째 방법은 정렬만없다면 시간복잡도가 O(n)이 나왔을 방법이다.
범위가 -30000 ~ 30000 인것을 이용해서, 카메라(진출시점)가 다음 원소 x의 진입시점보다 작으면 범위에 포함이 안되는것이므로
answer += 1을 해준다. 그리고 camera는 원소 x의 진출시점으로 갱신해준다.

근데 만약 카메라가 다음 원소의 진입시점보다 크다면, 이 카메라 한개로 다음 원소 x까지 퉁칠수 있으니깐 answer +=1 을 해줄필요가없다.
물론 camera를 다음원소 x의 진출시점으로 바꿔줄 필요도없다.

그렇게해서 routes의 개수만큼 for문을 돌려주면 끝인 문제이다.

꼭 복습을 하자. 어떤식으로든 응용되어 나올가능성이 충분한 문제이다.

"""

def solution(routes):
    answer, camera = 0, -30001
    routes.sort(key=lambda x: x[1])

    for r in routes:
        if camera < r[0]:
            answer += 1
            camera = r[1]
    return answer