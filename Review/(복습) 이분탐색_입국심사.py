"""

프로그래머스 이분탐색_입국심사 : LEVEL 3

이 문제를 처음 봤을때 당황하지 않고 푸는 사람이 몇이나 될까

우선 문제를 읽어보면 조건이 10억까지 가는거보면
단순하게 반복문만 돌린다고 해서 풀리는 문제는 아니라는것
그러니깐 범위가 겁나게 크다면 우선 범위를 줄여야 한다.

코딩테스트에 나오는 문제 중 큰 범위를 줄이는 문제는 대개 이분탐색 문제이다.
근데 거기까지밖에 생각이 도달하지 않는다.

이분탐색을 돌리려면 기준을 정해야 된다, 최소값 최대값을 보통 정하는데
최소값은 문제에서 조건을 1이라고 줬으니깐 left = 1 한다고 쳐도..

right(최대값)을 뭘로 설정할지에서 막혀서 답이없었다.
결국에는 또 인터넷에 있는 풀이를 살펴보게 되었다 ㅠㅠ

근데 인터넷 블로그에 계신 분들도 어려워서 고통스러워 하는거보니
어려운 문제는 맞나보다.

푸는 방식은 이렇다.
최소값은 잡았으니깐 넘어가고
최대값을 잡아주는게 관건인데, times에 있는 최대값에 n(사람 수)를 곱한것을
right(최대값)로 두는것이다.

즉 최대값은 처리시간이 제일 오래걸리는 심사관만을 이용해서 n명을 처리했을 경우 걸리는 시간이 최대값 인것이다.
mid값을 구해주면서 계산을 해나간다.

mid값이 향후에 답이 될 가능성이 높은 값이라 생각해도 된다.
계산을 계속할 때 count >= n 이면 right 값 조정,
count < n 이면 left 값 조정을 하는데 count는 사람 수 이기때문에 이게 무조건 n이상이 되긴 해야된다는 것이다.

만약 n보다 작게된다면 n명을 모두 입국심사를 하지않았다는것이기에 left(최소값)을 조정해서 다시 계산,
만약 n이상일경우에는 n명 이상을 입국심사 한거니깐 right(최대값)을 조정하여 다시 계산

이렇게 left, right 값 간의 간격을 줄이다보면 결국 한가지값에 가깝게 수렴하게 된다.
그 값이 답이 되는것이다.

복습은 반드시해야되고 너무 어려웠다 살려줘

"""

def solution(n, times):
    left, right = 1, (max(times) * n)

    while left <= right:
        mid = (left + right) // 2
        count = 0

        for t in times:
            count += mid // t
            if count >= n:
                break

        if count >= n:
            right = mid - 1
        else:
            left = mid + 1

    return left