"""

백준 문제 12904번 그리디_A와 B

그리디 문제였다. 난이도는 중하 ~ 중 정도의 문제이다.

이 문제의 핵심은 주어진 문자열 S, T에서
S에 문자를 추가해서 T로 만드는것보다 T에서 문자를 삭제해서 S로 만드는게 더 쉽다.
더 쉽다라기보다는 이게 올바른 접근법이다.
문자열의 맨앞, 맨뒤에서 삭제를 접근해야 하기때문에 deque 자료구조를 사용하는것이 좋다.

대신 문자열 연산 조건중 두번째가 ' 문자열을 뒤집고 뒤에 B를 추가한다. '
이 조건이기 때문에 문자를 삭제할때에는 B를 먼저 삭제하고 문자열을 뒤집어주면 된다.
그런데 실제로 문자열을 뒤집으면 뒤집을때마다 O(n)의 시간복잡도가 걸리기 때문에
반복문과 중첩되어 O(n^2)의 시간복잡도가 나오게 되서 좋지않음 알고리즘이 된다.
그러니깐 내가 푼것처럼 플래그를 둬서 체크를 하며 뒤집어 주면된다.
그러면 루프 돌때마다 문자열을 진짜로 뒤집지는 않아도 된다.

그렇게 진행하다가 마지막에 s와 t의 길이가 같아질때 반복문을 끝내주고,
rvs 플래그가 True일경우 뒤집어줘야 하는경우이니깐 뒤집어서 s == t를 확인해주면된다.
만약 플래그가 False일경우 뒤집지않고 그냥 s == t를 확인해주면 된다.

이 문제의 시간복잡도는 O(n) + O(n) = O(2n) ≈ O(n) 이다.

"""

from collections import deque

s, t = input().rstrip(), deque(input().rstrip())
rvs = False

while len(s) != len(t):
    if not rvs:
        if t[-1] == 'B':
            t.pop()
            rvs = True
        else:
            t.pop()
    else:
        if t[0] == 'B':
            t.popleft()
            rvs = False
        else:
            t.popleft()
if rvs:
    t.reverse()
print(1 if s == "".join(t) else 0)