"""

백준 문제 1783번 그리디_병든 나이트

처음에는 DFS/BFS 문제인줄 알고 접근했다가,
n, m의 범위가 엄청 크기때문에 무조건 시간초과가 발생하게 되어있다.

즉 이분탐색또는 단순계산/조건분기 문제라는건데
이분탐색을 사용할 파트는 아니니깐 단순계산/조건분기 문제라는것이다.

1. 2칸 위로, 1칸 오른쪽
2. 1칸 위로, 2칸 오른쪽
3. 1칸 아래로, 2칸 오른쪽
4. 2칸 아래로, 1칸 오른쪽

문제에서 제시된 4가지 이동법 중 공통사항은
무조건 위, 오른쪽으로 밖에 못간다는것이다.

그러면 생각해보자 n이 1일경우 위로 아래로도 못가니깐 스타트지점밖에 못서있는다 == 1칸

n이 2일경우 2번방법, 3번방법은 써먹을수가 있다.
다만 공통사항은 오른쪽으로 무조건 2칸은 간다는것이다.
그리고 문제에서 제시된 다른 조건은 이동횟수가 4번미만일경우 방법에는 제한이없다만, 4번이상일경우 각 방법을 한번씩 쓰라는것이다.
다르게 말하자면 min(4, (m + 1) // 2)과 같은말이다. 가로의 길이가 아무리 길어도 4번이 한계니깐 말이다.

이제 n이 3이상일경우에는 m을 가지고 기준을 나눠봐야된다.
n == 3, m == 7 일경우 위에 제시된 4가지방법을 모두 사용할 수가 있다.

즉 m < 7인경우에는 맥시멈으로 4가 나오거나 아니면 그 이하의 수만 나올수가 있다는 뜻이다.

m >= 7 인경우에는 이제 m이 1씩 늘어날때마다 1개씩 늘어난다고 생각하면된다.
예를들어 생각해보자 n=3, m=7인 경우에는 4개의 칸을 갈 수있다.
n=3, m=8인 경우에는 오른쪽으로 한칸 늘어난거니깐 오른쪽으로 두번가는 방법만 제외해서 쓰면된다.
즉 m-2가 답이다.

복습하자.

"""

import sys
input = sys.stdin.readline

n, m = map(int, input().split())
if n == 1:
    print(1)
elif n == 2:
    print(min(4, (m + 1) // 2))
else:
    if m < 7:
        print(min(4, m))
    else:
        print(m - 2)